<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F30%2F%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[###谈谈JavaScript中的函数 JavaScript是一个面向对象的语言，所以函数也是一个对象，而函数名则是一个指向函数对象的指针。对于定义函数的方法，有以下几种的方式： 1. 函数声明 function sum(num1,num2){ return num1+num2; } 函数声明，就是通过function关键字来定义声明一个函数，并且制定一个函数名。 2. 函数表达式 var sum = function(num1,num2){ return num1+num2; } 函数表达式即function关键字去定义一个变量后，不指定函数名，而是将这个函数给赋予一个变量，通过这个变量去定义。 3. 匿名函数 function (num1,num2) { return num1+num2; } 所以匿名函数，顾名思义就是没有函数名，当然之前讲到的函数表达式，赋予给一个变量的就是一个匿名函数。 4. 定义Function实例 var sayHi = new Function(&quot;sName&quot;, &quot;sMessage&quot;,“alert(&apos;Hello,&apos; + sName + sMessage);&quot;); 其中 &quot;sName&quot;, &quot;sMessage&quot;为参数名，“alert(&apos;Hello,&apos; + sName + sMessage);&quot;为函数体。 调用的时候也是一样例如sayHi(&quot;Zhang, &quot;,&quot;come here!&quot;); 对于函数声明和函数表达式，它们的不同点在于使用函数声明的时候，会通过提升当前作用域上的函数声明，即函数定义了window对象的方法，而函数表达式则须的等到Javascript引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。 例如对应情境： 情形1：调用错误(sum作为函数对象，必须先定义再引用) alert(sum(10,10)); // 出错 var sum= function(num1,num2){ return num1+num2; } 情形2：调用正确(函数定义是全局的，可以在定义前引用) alert(sum(10,10)); // 20 function sum(num1,num2){ return num1+num2; } 以上都是些函数很基本的定义方式，有那么多定义方式其实我经常用的其实也只有函数定义和函数表达式，但也经常发现在调用函数的时候，除了通过函数定义之后去调用外，还有种方式就是立即执行函数(IIFE)，即 (function(){})()。 其实这也算函数定义和函数表达式的区别之一，例如说： function(){ console.log(1) }(); //出错 上面这个代码出现报错&quot;Uncaught SyntaxError: Unexpected token (&quot;，因为在执行这段代码的时候，会将其看作是一个函数声明而不是一个函数表达式，而函数声明需要函数名，所以执行到function后的第一个括号的左括号(时就会报错了，因为这个左括号之前需要一个函数名嘛。 那假设加上函数名之后呢？ function foo(){ console.log(1) }(); //出错 这样也仍然出错，这是为什么呢，我明明把之前遇到的问题解决了？我们把目光看到表达式最后面的一对括号上，在一个函数声明后面加上了一对括号难倒不感觉有点违和吗，其实现在这对括号仅仅是分组运算符而已，啥是分组运算符咧，其实就跟我们运算式里用来控制优先级的小括号一样，我们可以把上面的代码看成这样： function foo(){ console.log(1) } (); 相当于把是分开的两个操作，而执行下面的()的表达式运算时，()里的表达式不能为空，所以上面的代码会报&quot;Uncaught SyntaxError: Unexpected token )&quot;的错误，因为右括号)前没有内容。(不信可以尝试function foo(){ console.log(1) }(console.log(2));就不会报错，而且出现的结果是2) 所以这个立即执行函数是怎样的呢？其实也就是下面的两种常见写法（效果是一样的） (function(){ /* code */ }()); (function(){ /* code */ })(); 像我们之前讲的，Javascript引擎看到function关键字会认为是函数声明语句，但如果 Javascript引擎先看到小括号呢？那它就自动把里面的代码识别为一个函数表达式而不是一个函数声明。 但其实要让Javascript引擎认为这是一个表达式的方法还有很多，例如： !function(){}(); +function(){}(); -function(){}(); ~function(){}(); void function(){}(); new function(){ /* code */ } new function(){ /* code */ }() // 只有传递参数时，才需要最后那个圆括号。 那为啥要有立即执行函数呢，存在即合理嘛，有了立即执行函数，我们就可以解决一下全局变量污染问题。（这又想，啥是全局变量污染问题，其实就JavaScript 可以随意定义保存所有应用资源的全局变量。但全局变量可以削弱程序灵活性，增大了模块之间的耦合性。在多人协作时，如果定义过多的全局变量 有可能造成全局变量冲突），立即执行函数也就可以把作用域隔离开来，此时若是想访问全局对象，将全局对象以参数形式传进去即可。以前用jQuery的时候其实用的都是用的立即执行函数的原理。 与此同时，立即执行函数又与闭包有不得不说的关系，关于闭包就留在下一次详细来谈谈吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS-作用域和闭包]]></title>
    <url>%2F2018%2F08%2F15%2FJS-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言 在看了《你不知道的JS》上卷的第一章后，希望在这里记下自己的收获，加深对知识的理解。 关于LHS和RHS 其实LHS和RHS就是变量的赋值操作，其中L代表一个赋值操作的左侧，R代表右侧。刚刚看这一段的时候有种似懂非懂的感觉，但是接下去读就会明白这两者是怎么一回事。 最终理解是在1.5小结部分，里面说到如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。当然结合里面的一个小例子就会更加明白，以下是这个小例子,问的是找出所有的LHS和RHS：12345function foo(a) &#123; var b = a; return a + b;&#125;var c = foo( 2 ); 首先是看到var c里的c需要被赋值，所以进行一次LHS，变量c被赋值的是foo(2)，在这里就要获得foo(2)的值，所以进行一次RHS，将2传递给function foo(a){……}函数的参数a进行了一次隐式变量分配a=2，进行了一次LHS，在函数foo里面，对变量b进行赋值需要对b进行LHS，对变量b所赋的值a要知道从哪里来，这里要获得a的值就要交进行一次RHS，最后return a+b中需要找到a和b的值，所以对a和b进行RHS。这里总共有3个LHS和4个RHS。 看完这个例子我就已经基本明白LHS和RHS的区别就是LHS是对某物给它一个东西，而RHS是找到某物是什么东西。 作用域函数作用域 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 其实函数作用域就是对局部变量来说的，在函数内定义的变量在函数外取不到。 书中还有一个就是区分函数声明和表达式，最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。还有就是关于匿名函数、具名函数，在这里就不再记录，有需要的时候可以再去查看具体资料。 此外还有一个立即执行函数表达式（IIFE，Immediately Invoked Function Expression）， 最常见的用法是使用一个匿名函数表达式。如：123456var a = 2;(function foo() &#123; var a = 3; console.log( a ); // 3&#125;)();console.log( a ); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
</search>
