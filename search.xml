<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xieyq]]></title>
    <url>%2F2018%2F12%2F29%2Fxieyq%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS-作用域和闭包]]></title>
    <url>%2F2018%2F08%2F15%2FJS-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言 在看了《你不知道的JS》上卷的第一章后，希望在这里记下自己的收获，加深对知识的理解。 关于LHS和RHS 其实LHS和RHS就是变量的赋值操作，其中L代表一个赋值操作的左侧，R代表右侧。刚刚看这一段的时候有种似懂非懂的感觉，但是接下去读就会明白这两者是怎么一回事。 最终理解是在1.5小结部分，里面说到如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。当然结合里面的一个小例子就会更加明白，以下是这个小例子,问的是找出所有的LHS和RHS：12345function foo(a) &#123; var b = a; return a + b;&#125;var c = foo( 2 ); 首先是看到var c里的c需要被赋值，所以进行一次LHS，变量c被赋值的是foo(2)，在这里就要获得foo(2)的值，所以进行一次RHS，将2传递给function foo(a){……}函数的参数a进行了一次隐式变量分配a=2，进行了一次LHS，在函数foo里面，对变量b进行赋值需要对b进行LHS，对变量b所赋的值a要知道从哪里来，这里要获得a的值就要交进行一次RHS，最后return a+b中需要找到a和b的值，所以对a和b进行RHS。这里总共有3个LHS和4个RHS。 看完这个例子我就已经基本明白LHS和RHS的区别就是LHS是对某物给它一个东西，而RHS是找到某物是什么东西。 作用域函数作用域 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 其实函数作用域就是对局部变量来说的，在函数内定义的变量在函数外取不到。 书中还有一个就是区分函数声明和表达式，最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。还有就是关于匿名函数、具名函数，在这里就不再记录，有需要的时候可以再去查看具体资料。 此外还有一个立即执行函数表达式（IIFE，Immediately Invoked Function Expression）， 最常见的用法是使用一个匿名函数表达式。如：123456var a = 2;(function foo() &#123; var a = 3; console.log( a ); // 3&#125;)();console.log( a ); // 2 由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
</search>
